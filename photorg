#!/usr/bin/python

import pyexiv2
import argparse
import os
import sys
import hashlib
from shutil import copyfile

"""

Note about the Exiv2 library
	pyexiv2 is depreciated in favor of gexiv2 (gobject based)
	this may cause cross platform issues
	https://wiki.gnome.org/Projects/gexiv2


Metadata of interest (http://exiv2.org/iptc.html)

	Location
		Iptc.Application2.City
		Iptc.Application2.SubLocation
		Iptc.Application2.ProvinceState
		Iptc.Application2.CountryCode
		Iptc.Application2.CountryName

	Caption
		Iptc.Application2.Headline
		Iptc.Application2.Caption

	Keywords
		Iptc.Application2.Keywords
		Iptc.Application2.Subject
		Iptc.Application2.Category
		Iptc.Application2.SuppCategory
	
	Rating
		Iptc.Application2.Urgency

"""


xmp_template = """<?xpacket begin="<feff>" id="W5M0MpCehiHzreSzNTczkc9d"?>
<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="XMP Core 4.4.0-Exiv2">
 <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
  <rdf:Description rdf:about=""
    xmlns:xmp="http://ns.adobe.com/xap/1.0/"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:darktable="http://darktable.sf.net/"
   xmp:Rating="1"
   darktable:xmp_version="1"
  </rdf:Description>
 </rdf:RDF>
</x:xmpmeta> 
<?xpacket end="w"?>"""



class MetadataError(Exception):
	pass

	

	
class ImageMetadata(object):

	def __init__(self, path):
		# try to read image and xmp metadata
		# create xmp if it does not exist
		# raise error if either fail
		self.path = path.rstrip('.xmp') # this may not be necessary / errors could be handled in other ways
		self._load_metadata()
		self._load_sidecar()

	def _load_metadata(self):
		"""
		given a path to an image or an xmp file, return a Metadata object
		Metadata objects provide coordinated access to metdata in either xmp or image files
		saving 
		"""

		# try to open the image file, throw exception if DNE
		try:
			self._img_metadata = pyexiv2.ImageMetadata(self.path)
			self._img_metadata.read()

		except Exception as e:
			raise MetadataError(e.message)


	def _load_sidecar(self, create=False):
	
		self.sidecar_path = self.path + '.xmp'
		
		# try to open xmp file if it exists
		if os.path.exists(self.sidecar_path):
			try:
				self._xmp_metadata = pyexiv2.ImageMetadata(self.sidecar_path)
				self._xmp_metadata.read()

			except Exception as e:
				raise MetadataError(e.message)

		# if xmp file DNE, create it
		elif create:
			with open(self.sidecar_path,'w') as f:
				f.write(xmp_template)



	def __getitem__(self, key):
		
		# first check the xmp source
		if hasattr(self, '_xmp_metadata') and key in self._xmp_metadata:
			return self._xmp_metadata[key].value

		# then check the image source
		elif key in self._img_metadata:
			return self._img_metadata[key].value

		# Tag is either not set or name is invalid - either way it's not set
		else:
			raise KeyError('Tag not set ({key})'.format(key=key))
		

	def __setitem__(self, key, value):
		"""set value and save to disk"""
		print "Not implimented"



def ls(path, include_hidden=False):
	"""
	walk the filesystem
	return list of paths rooted at path
	if visitor is specified, return (path, visitor(path)) unless visitor(path) is None 
	"""
	pathlist = []
	path = os.path.realpath(path)

	for root, dirs, files in os.walk(path):
		for name in files:
			# skip hidden files as appropriate
			if not include_hidden and name.startswith('.'):
				continue
	
			yield os.path.join(root, name)
			

def new_event_dir(base, date):
	event_dir = os.path.join(base, date.strftime("%Y-%m-%d"))
	if not os.path.exists(event_dir):
		os.makedirs(event_dir, 0755)
		print "New Event:", event_dir
	return event_dir



def copy_file(source, target, target_is_dir=False):
	"""
	Copy source file to target directory. 
	On unix, first try to hard-link. If that fails, perform regular copy.
	
	source := file to copy
	target := destination path 
	target_is_dir := copy the source file to the target directory and perserve filename

	"""

	# first make sure that the source path exists:
	if not os.path.isfile(source):
		raise Exception('File does not exist (or is not a regular file): ' + source)

	# target could be a file or directory, expand path as appropriate
	if target_is_dir:
		target_dir = target
		target_path = os.path.join(target, os.path.basename(source))

	else: 
		target_dir = os.path.dirname(target)
		target_path = target

	# create directory if it doesn't exist
	if not os.path.isdir(target_dir):
		# if this raises an exception then something is actually wrong
		# probably target_is_dir was used incorrectly
		os.makedirs(target_dir, 0755)

	# if the target file already exists, check if the it's different
	if os.path.exists(target_path):
		
		if os.path.samefile(source, target_path):
			# files are the same inode, can safely skip
			return

		# check if they have the same size but different hash
		elif os.stat(source).st_size == os.stat(target_path).st_size:
			
			# check if they are the same hash
			with open(source) as source_file:
				with open(target_path) as target_file:
					source_hash = hashlib.sha1(source_file.read()).hexdigest()
					target_hash = hashlib.sha1(target_file.read()).hexdigest()
					if source_hash != target_hash:
						# file exists but has different hash
						sys.stderr.write('Destination file exists but has different hash: {src}, {dest}\n'.format(src=source, dest=target_path))
						return

		else:
			# target file exists but is a different size
			sys.stderr.write('Destination file exists and is different size: {src}, {dest}\n'.format(src=source, dest=target_path))
			return

	# file did not already exist
	else:

		# create a hardlink on unix
		try:
			os.link(source, target_path)
			if VERBOSE: print "Linking: {s} -> {t}".format(s=source, t=target_path)
		
		# otherwise, copy the file
		except OSError as e:
			if VERBOSE: print "Copying: {s} -> {t}".format(s=source, t=target_path)
			copyfile(source, target_path)




def organize_by_event(source_dir, dest_dir, day_delta=4, other_dir=None): 
	
	# locals
	event_date = None
	event_dir = None
	dest = os.path.realpath(dest_dir)
	source = os.path.realpath(source_dir)
	metadata_list = []
	other_list = []
	dir_to_metadata = {} # {directory, [img_metadata]}

	# walk the source directory and separate photos (with metadata) from everything else
	for path in ls(source):
		
		try:
			# create a metadata object and check for the date key
			imd = ImageMetadata(path)
			date = imd['Exif.Image.DateTime']
			metadata_list.append(imd)
			# update the Dir->ImageMetadata map
			dir_to_metadata.setdefault(os.path.dirname(imd.path), []).append(imd)

		except MetadataError as e:
			# This was not an image (or did not have a date attribute)
			other_list.append(path)
	
		except KeyError as e:
			sys.stderr.write(str(e) + ": " + path + "\n")

	# update progress counters
	total_count = len(metadata_list) + len(other_list)
	current_count = 0

	# iterate over all ImageMetadata objects sorted by Exif.Image.DateTime
	for metadata in sorted(metadata_list, key=lambda md: md['Exif.Image.DateTime']):
		date = metadata['Exif.Image.DateTime']

		# first iteration: initialize date and create event dir
		if not event_date: 
			event_date = date
			event_dir = new_event_dir(dest, event_date)
		
		# decide if time delta is large enough to start a new event
		delta = date - event_date 
		if delta.days > day_delta:
			# new event, create event directory 
			event_date = date
			event_dir = new_event_dir(dest, event_date)
			#print "="*3, label + " / " + str(delta.days), "="*3
		
		# copy file to event_dir
		copy_file(metadata.path, event_dir, target_is_dir=True)

		# update progress
		current_count += 1
		# FIXME: print progress

	# now deal with the non-images and other files without metadata
	for path in other_list:
		# if there were any images in the same directory as this file, use them to determine nearest event
		# dirname = os.path.dirname(path)
		# FIXME, logic is not quite right, all non-image files will get coppied this way
		#if dirname in dir_to_metadata:
			# sort all the metadata objecst in the same directory as this file by the hamming distance between paths
			#metadata_in_same_dir = dir_to_metadata[dirname]
			#imd = sorted(metadata_in_same_dir, key=lambda imd: path_distance(path, imd.path))[0]
			# put this file in the same event directory 
			#event_dir = new_event_dir(dest, imd['Exif.Image.DateTime'])
			#print "Copying non-image file: ", path, " -> ", event_dir
			#print "    Closest image path: ", imd.path
			#print "         Path distance: ", str(path_distance(path, imd.path))
			#copy_file(path, event_dir)

		# if the user specified an alternate directory for non-image files
		if other_dir:
			# preserve the directory structure as a subdirectory 
			prefix = os.path.commonprefix([path, source])
			subpath = path.replace(prefix,'',1).strip(os.path.sep)
			target = os.path.join(other_dir, subpath) 
			#sys.stderr.write('Copying non-image file to alternate directory: ' + path + '\t' + target  + '\n') 
			copy_file(path, target)
		
		else:
			# there were no image metadata objects in the same directory as this path
			sys.stderr.write('Skipping non-image file: ' + path + '\n')



def path_distance(x,y):
	"""Calculate the number of trailing characters that are not equal between two strings."""
	return len(x.lstrip(y))



def print_exiv2_metadata(path):
	m = pyexiv2.ImageMetadata(path)
	m.read()
	tags = []

	# check all possible tags
	for key in m.keys():
		try:
			tag = m[key]
			if tag.value:
				tags.append(tag)
		
		except KeyError as e:
			# Tag not set
			pass

		except pyexiv2.exif.ExifValueError as e:
			# Invalid value for EXIF type
			pass

	# now print tags with values
	for tag in tags:
		if tag.type == 'Undefined':
			value = "<DATA>"
		else:
			value = str(tag.value)
		
		print tag.key.rjust(45) + ': ' + value



if __name__=='__main__':

	parser = argparse.ArgumentParser(description='Photo organization')
	parser.add_argument('--organize', metavar=('SOURCE','DEST'), nargs=2, help='organize the photos')
	parser.add_argument('--other', help='directory to copy non-image and other unsupported files')
	parser.add_argument('--gap', type=int, default=4, help='The minimum number of days between events.')
	parser.add_argument('--show', metavar='IMG', help='show metadata for given image file')
	parser.add_argument('--verbose', action='store_const', const=True, help='display verbose file operations and other info')
	args = parser.parse_args()
	
	# set verbose flag
	global VERBOSE
	VERBOSE = args.verbose if args.verbose else False

	# print EXIF data for an image
	if args.show:
		print_exiv2_metadata(args.show)

	# organize and copy files from SOURCE into DEST
	if args.organize:
		source,dest = args.organize
		other = args.other if args.other else os.path.join(dest,'photorg_other_files')
		organize_by_event(source, dest, args.gap, other)

	# help
	else:
		parser.print_usage()


